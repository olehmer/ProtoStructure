from AtmosClasses import Layer
import matplotlib.pyplot as plt
import numpy as np
import sys
from math import e, pi, exp, isnan
from scipy import optimize




################Constants########################
M_Earth = 5.972E24 #mass of Earth in [kg]
R_Earth = 6.371E6 #radius of Earth [m]
GG = 6.67408E-11 #gravitational constant [m3 kg-1 s-2]
R_H2 = 4124.0 #gas constant for H2 [J kg-1 K]
SIGMA = 5.67E-8 #Stefan Boltzman constant



#################End Constants###################


def CalculateTopU(layer, R_gas):
    """
    This function will calculate the radial outflow (u) from the top of the 
    atmosphere. It will also calculate the mass loss generated by that flow.

    Input:
    layer - the layer to calculate the loss rate of
    R_gas - the specific gas constant for atmosphere

    Returns:
    (cur_loss, u) - a tuple containing the current loss rate [ kg s-1] and the
                    radial outflow of the layer [m s-1]
    """

    #calculate the total flux received at this layer
    F_in = layer.F_uv + layer.F_sol + layer.F_up + layer.F_down
    
    def equations(vals):
        """
        The helper function called by fsolve. This will solve for T and u for
        the layer.
        """

        T, u = vals #get the values from the input
        u0_sqrd = R_gas*T #the isothermal sound speed
        r_c = GG*layer.m_below/(2.0*u0_sqrd) #the critical radius where u=u0
        r_l = layer.r
        M = layer.m_below
        #see paper for equations TODO - numbers for these?
        eqn1 = u - u0_sqrd*(r_c/r_l)**2.0*exp(-0.5+GG*M/(u0_sqrd)*(1.0/r_c-1.0/r_l))
        eqn2 = F_in - (GG*M/r_l*u*layer.rho + SIGMA*T**4.0)

        return (eqn1, eqn2)
    
    vals_in = (layer.T, 10.0) #10 is just a guess for the first time
    if layer.u > 0:
        vals_in = (layer.T, layer.u)

    T, u = optimize.fsolve(equations,vals_in)

    if T < 0 or u < 0 or isnan(T) or isnan(u): 
        #if u~0 then the solver can get confused and give things like -1E-30
        #in that case it can mess up the rest of the program, just return 0
        return (0.0,0.0)
    else:
        cur_loss = 4.0*pi*layer.rho*u*layer.r**2.0
        return (cur_loss, u) 


def UpdateLayerVelocity(layers, ind, R_gas, cur_loss):
    """
    This function takes the array of layers and the current index to update. 
    It will update the radial outflow velocity, u, at each layer.

    IMPORTANT: this must be called after UpdateR() as the appropriate distance
    for each layer is needed to calculate the new u value.

    Input:
    layers - the array of layers in the atmosphere
    ind - the index of the layer to operate on in layers array
    R_gas - the specific gas constant for the atmosphere
    cur_loss - the current loss rate from the top of the atmosphere. When 
               calling this function on the first layer (ind=0) this function
               will set cur_loss. All subsequent calls should just pass that
               value back to this function.

    Updates layers directly

    Returns:
    cur_loss - the current loss rate [kg s-1] from the top of the atmosphere.
               This is only calculated for the top layer then passed on all 
               subsequent layers for ease of computation.
    """

    if ind==0:
        #this is the top layer, calculate the loss rate from the top layer
        cur_loss, u = CalculateTopU(layers[ind], R_gas)
        print("cur_loss=",cur_loss)
        print("u=",u)
        layers[ind].u = u
    else:
        #not the top layer, calculate u based on cur_loss
        u = cur_loss/(layers[ind].rho*layers[ind].r**2.0)
        layers[ind].u = u

    return cur_loss

def UpdateLayerDuDr(layers, ind):
    """
    This function will update the du/dr value for each layer. The du/dr of each
    layer will be set by looking at the slope of the layer above and below (in
    the case of the top layer the slope will be approximated from just the top
    layer and the one below).

    Input:
    layers - the layers of the amtosphere
    ind - the index of the layer to process
    
    Updates layers directly
    """

    du_dr = 0.0
    if ind == 0:
        #this is the top layer, don't look at a layer above (there isn't one...)
        du_dr = (layers[ind].u-layers[ind+1].u)/(layers[ind].r-layers[ind+1].r)
    elif ind == len(layers)-1:
        #if this is the bottom layer we're in the same situation, just use 2 layers
        du_dr = (layers[ind-1].u-layers[ind].u)/(layers[ind-1].r-layers[ind].r)
    else:
        #this isn't the top or bottom, use the u values form surrounding layers
        du_dr = (layers[ind-1].u-layers[ind+1].u)/(layers[ind-1].r-layers[ind+1].r)

    layers[ind].du_dr = du_dr


def UpdateLayerDistance(layers, ind, R_gas, core_rad):
    """
    This function will calculate the radial distance of the current layer. This
    is done by assuming the layer is approximately isothermal and gravity is
    constant throughout the layer. The first time this function is called g is
    assumed constant throughout the atmosphere. Once r has been calculated 
    gravity can be calculated for each layer (based on previous r).

    IMPORTANT: this function starts from the ground layer first, then works
    up!

    Input:
    layers - the array of layers in the atmosphere
    ind - the index of the current layer in the layers array
    R_gas - the gas constant for the atmosphere
    core_rad - the radius of the planetary core

    Updates layers directly
    """

    #make a temporary index (t_ind) to reverse the direction
    t_ind = len(layers)-ind-1 #reverse the direction, we want to start at the ground

    g = 0.0 #define gravity, g [m s-2]

    if layers[t_ind].r == -1: #not set yet
        g = GG*layers[t_ind].m_below/core_rad**2.0 #gravity!
    else:
        g = GG*layers[t_ind].m_below/layers[t_ind].r**2.0

    #in addition to g at each layer we also have du/dr as an upward acceleration
    #scale height is given by RT/(g-u*du/dr)
    #scale height, the altitude for which pressure decreases by e (~1/3)
    H = R_gas*layers[t_ind].T/(g-layers[t_ind].u*layers[t_ind].du_dr)
    
    p_factor = layers[t_ind].p_bot/layers[t_ind].p_top 

    delta_r = p_factor*H #this is the height of the layer
    layers[t_ind].h = delta_r #record the height of the layer

    if ind == 0:
        #this is the bottom layer
        layers[t_ind].r = core_rad + delta_r/2.0 #the middle of the layer
    else:
        #this isn't the bottom layer
        layers[t_ind].r = layers[t_ind+1].r +layers[t_ind+1].h/2.0 + delta_r/2.0




def UpdateLayerPressure(layers, ind):
    """
    This function will update the pressure bounds of each layer. This is done
    using P=m*(g-u*du/dr) at each layer then summing from top to bottom.

    Inputs:
    layers - the array of layers in the atmosphere
    ind - the index of the current layer to process

    Updates layers directly
    """

    g = GG*layers[ind].m_below/layers[ind].r**2.0
    area = 4.0*pi*layers[ind].r**2.0
    p_layer = layers[ind].m*(g-layers[ind].u*layers[ind].du_dr)

    if ind != 0:
        #this isn't the top layer so add the pressure from the above layers
        p_layer = p_layer + layers[ind-1].p_bot
        layers[ind].p_top = layers[ind-1].p_bot

    layers[ind].p_bot = p_layer

def UpdateTempProfile(layers, T_profile):
    """
    Simply loop over the layers and copy the temperature value to T_profile.
    This will also compute the difference between the old T and the new T.

    Input:
    layers - the atmospheric layers
    T_profile - the temperature at each atmospheric layer

    Updates T_profile directly

    Return:
    diff - the difference between the current T_profile and the old one
    """

    diff = 0.0
    for i in range(0,len(layers)):
        diff += abs(T_profile[i] - layers[i].T)
        T_profile[i] = layers[i].T

    return diff

def LayersInit(N, total_flux, core_mass, core_rad, atmos_mass, R_gas,\
        p_toa=-1.0, T_prof=[]):
    """
    This function will generate an array of N layers for the atmosphere assuming
    the initial atmosphere is in hydrostatic equilibrium and isothermal.

    Inputs:
    N - the number of atmospheric layers to use
    total_flux - the total incident flux. This will be used to set the isothermal
                 atmospheric temperature if no T_prof is provided [W m-2]
    core_mass - the mass of the planet core [kg]
    core_rad - the radius of the planet core [m]
    atmos_mass - the mass of the atmosphere [kg]
    R_gas - the specific gas constant for the atmosphere [J kg-1 K]
    p_toa - optional parameter to set the pressure at the top of the model. If
            not set the top of the model will be set to 1E-5 of whatever the 
            surface pressure is.
    T_prof - optional parameter to specify the initial atmospheric temperature
             profile. If a reasonable profile can be guessed this will make the
             radiative transfer code much faster. NOTE: T_prof should have the
             top layer temperature at index 0.

    Returns:
    layers - the array of atmospheric layers
    """

    g = GG*(core_mass+atmos_mass)/core_rad**2.0 #calculate gravity
    iso_T = (total_flux/SIGMA)**(0.25) #estimate the isothermal temperature

    #calculate the surface pressure
    p_s = atmos_mass*g/(4.0*pi*core_rad**2.0)

    #calculate the TOA pressure
    if p_toa < p_s: #don't reset p_toa if it's passed in and valid
        p_toa = p_s*1.0E-4

    #Create the pressure profile for the atmosphere, log scale and linear are below
    p_profile = np.logspace(np.log10(p_s),np.log10(p_toa), N+1) #log scale
    #p_profile = np.linspace(p_s, p_toa, N) #linear scale

    #create the layers array that we'll be working with
    layers = []

    #keep track of the total mass so far
    cur_mass = core_mass

    #planetary surface area, assumed ~constant in the hydrostatic atmosphere
    area = 4.0*pi*core_rad**2.0

    for i in range(0,N):
        p_bot = p_profile[i]
        p_top = p_profile[i+1]

        mass = (p_bot-p_top)*area/g #approximate mass of the layer
        
        T = iso_T
        if len(T_prof) > 0:
            T = T_prof[N-i-1] #we're building the atmosphere from the bottom up

        rho = ((p_bot-p_top)/2.0)/(R_gas*T) #estimate the density with the average pressure

        layer = Layer(p_bot=p_bot, p_top=p_top, m=mass, m_below=cur_mass, T=T, rho=rho)
        layers.insert(0,layer) #prepend the layer in our array

        cur_mass = cur_mass + mass #increment the total mass

    return layers

def UpdateLayerRadTrans(layers, ind, F_uv, F_sol, F_long, kappa_uv, \
        kappa_sol, kappa_long, uv_p_ref, sol_p_ref, long_p_ref, R_gas):
    """
    This function will calculate the radiative profile of the atmosphere. This 
    is a purely radiative model with a single, pressure scaled, optical depth
    for each flux channel.

    IMPORTANT: this model assumes that the atmosphere will only emit in the
               longwave. Any photons absorbed in the UV or sol band are assumed
               to go to kinetic energy and photons in the longwave.

    Inputs:
    layers - the atmospheric layers layer
    ind - the atmospheric layer to work with
    ground_ T- The temperature of the ground (assumed a blackbody absorber) [K]
    F_uv - the TOA flux [W m-2]
    F_sol - the TOA ~visible flux [W m-2]
    F_long - the TOA longwave flux, typically 0
    kappa_uv - the mass absorption coefficient for the UV
    kappa_sol - the mass absorption coefficient for the visible
    kappa_long - the mass absorption coefficient for the longwave radiation
    uv_p_ref - the reference pressure that kappa_uv was measured at
    sol_p_ref - the reference pressure that kappa_sol was measured at
    long_p_ref - the reference pressure that kappa_long was measured at
    R_gas - the specific gas constant for the atmosphere

    Updates layers directly
    """

    g = GG*layers[ind].m_below/layers[ind].r**2.0 #gravity at the layer

    #calculate the optical depth for each channel TODO need equation number here
    #optical depth is approximated by tau=kappa_ref*pressure^2/(2*g*pressure_ref)
    p_avg = (layers[ind].p_bot-layers[ind].p_top)/2.0
    tau_uv = kappa_uv*(p_avg)**2.0/(2.0*g*uv_p_ref)
    tau_sol = kappa_sol*p_avg**2.0/(2.0*g*sol_p_ref)
    tau_long = kappa_long*p_avg**2.0/(2.0*g*long_p_ref)

    #calculate the absorption in each band
    abs_uv = 1.0 - exp(-tau_uv)
    abs_sol = 1.0 - exp(-tau_sol)
    abs_long = 1.0 - exp(-tau_long)

    if ind == 0:
        #this is the top layer, set the fluxes from the TOA
        #This could be done outside this function, but was kept here for readability
        layers[ind].F_uv = F_uv
        layers[ind].F_sol = F_sol
        layers[ind].F_down = F_long

    #calculate the total flux absorbed in the layer
    F_in = abs_uv*layers[ind].F_uv + abs_sol*layers[ind].F_sol + \
            abs_long*layers[ind].F_up + abs_long*layers[ind].F_down

    #now calculate the new energy balance to get the temperature
    #TODO this needs an equation
    #F_in = GM/r*rho*u + simga*T^4
    M = layers[ind].m_below
    r = layers[ind].r
    rho = layers[ind].rho
    u = layers[ind].u
    T = ((F_in - GG*M/r*rho*u)/(abs_long*SIGMA))**(0.25)

    #with the new temperature update the layer density and T
    if T > 0.0: #ORL TODO THIS IS THE PROBLEM??????????????
        #on the first pass through the atmosphere (if not shortwave abosroption
        #the layers won't absorb until the flux reaches the surface
        new_rho = p_avg/(R_gas*T)
        layers[ind].T = T
        layers[ind].rho = new_rho
    else:
        #the calculated T isn't good yet
        T = layers[ind].T

    #calculate the longwave emission from the layer
    F_emit = abs_long*SIGMA*T**4.0

    #now calculate how much radiation is passed to the layer below
    if ind < len(layers)-1:
        #this isn't the bottom layer
        layers[ind+1].F_uv = layers[ind].F_uv*(1.0-abs_uv)
        layers[ind+1].F_sol = layers[ind].F_sol*(1.0-abs_sol)
        layers[ind+1].F_down = layers[ind].F_down*(1.0-abs_long) + 0.5*F_emit
    else:
        #this is the bottom layer, update the ground upward flux 
        F_total = layers[ind].F_uv*(1.0-abs_uv) + layers[ind].F_sol*(1.0-abs_sol) +\
                layers[ind].F_down*(1.0-abs_long) + 0.5*F_emit

        #ground_T = (F_total/SIGMA)**(0.25)
        #from the ground temp the upward flux is thus F_total
        #update the upward flux of the bottom layer
        layers[ind].F_up = F_total

    #now calculate the flux passed in the up direction
    if ind > 0:
        #not the top layer
        #note, only longwave flux can be passed upward in this model
        layers[ind-1].F_up = layers[ind].F_up*(1.0-abs_long) + 0.5*F_emit




        
def BalanceAtmosphere(core_mass, core_rad, atmos_mass, R_gas, F_uv, F_sol, F_long,\
        kappa_uv, kappa_sol, kappa_long, uv_p_ref, sol_p_ref, long_p_ref,\
        T_prof_in=[], N=100, iter_lim=200, tol=1.0E-4, p_toa_in=-1.0):
    """
    This is the top level function to balance the atmospheric model. Given the 
    above parameters this will compute the temperature profile, pressure 
    profile, height profile, and the loss rate from the atmosphere. This model uses a 3-stream
    approach to handle UV, visible, and IR flux.

    IMPORTANT: all the passed in flux values (F_uv, F_sol, F_long) should have
               the albedo already taken into account. This model will not 
               calculate scattering or any other form of reflection.

    Inputs:
    core_mass - the mass of the planetary core [kg]
    core_rad - the radius of the planetary core [m]
    atmos_mass - the mass of the atmosphere [kg]
    R_gas - the specific gas constant for the atmosphere [J kg-1 K]
    F_uv - the downward UV flux at the top of the atmosphere [W m-2]
    F_sol - the non-UV non-longwave downward flux at the top of atmos [W m-2]
    F_long - the longwave downward flux at TOA, typically 0 [w m-2]. 
    kappa_uv - the mass absorption coefficient for the UV band [m2 kg-1]
    kappa_sol - the mass absorption coefficient to use in the solar band [m2 kg-1]
    kappa_long - the mass absorption coefficient to use in the longwave band [m2 kg-1]
    uv_p_ref - the reference pressure for kappa_uv
    sol_p_ref - the reference pressure for kappa_sol
    long_p_ref - the reference pressure for kappa_long
    T_prof_in - optional temperature profile can be passed in
    N - the number of atmospheric layers to use in the simulation, defaults to 100
    iter_lim - the number of iterations after which the model will stop
    tol - the desired tolerance for model accuracy (looks at the temp profile change)
    p_toa_in - the pressure at the top of the atmosphere to be used in the model [Pa].
               Leaving this at the default of -1 will result in the model auto
               generating the pressure at TOA

    NOTE: TOA = top of atmosphere, and TOA is at and index of 0 in our layers array

    Output:
    p_profile - the pressure profile of the atmosphere
    r_profile - the radial distance of each layer
    T_profile - the temperature profile of the atmosphere
    mass_flux - the mass flux loss rate from the atmosphere [kg s-1]
    """
    
    if len(T_prof_in)>0 and len(T_prof_in) != N:
        #this is a problem, need a temperature for each layer
        print("Temperature profile input had %d layers \
                but the model expects %d"%(len(T_prof_in),N))
        sys.exit(1)

    #initialize our array to hold the layers
    total_flux = F_uv + F_sol + F_long
    layers = LayersInit(N, total_flux, core_mass, core_rad, atmos_mass, R_gas,\
            p_toa=p_toa_in, T_prof=T_prof_in)

    T_profile = np.zeros(N) #initialize temperature profile
    UpdateTempProfile(layers, T_profile)

    count = 0 #keep track of what iteration we're on
    diff = tol + 1.0 #track our current level of accuracy

    while count<iter_lim and diff>tol:
        """
        This is where all the time will be spent for this algorithm. There are
        lots of seemingly redundant loops below, but they are important. The
        order of the loops also matters. The general steps are:

        1. Calculate the radial distance, r, for each layer
        2. Once r is known, we can calculate velocity (u)
        3. Once u is known for each layer we can find du/dr
        4. With r, u, and du/dr we can calculate the new pressure for the layer
        5. Update the radiative transfer (aka update temperature)

        An aside:
        If you're sufficiently clever you can probably combine some of the loops
        below, but the runtime will still be O(N) so probably not worth the
        effort.
        """

        #1 - first update the distance to each layer
        print("STARTING R!!!!!!!!!!!!!!!!!!!")
        for i in range(0,N):
            UpdateLayerDistance(layers, i, R_gas, core_rad)

        #2 - next update the radial outflow velocity for each layer
        if count > 200:
            #ORL TODO the rad trans needs to run at least once outside this loop
            #for N times, so all the layers will have flux values!
            print("STARTING u calc!!!!!!!!!!!!!!!!!!!!!!!!!!!")
            cur_loss = 0.0 #initialize to 0
            for i in range(0,N):
                cur_loss = UpdateLayerVelocity(layers, i, R_gas, cur_loss)
                print("%2d: u=%f"%(i,layers[i].u))
        
        #3 - update the du/dr for each layer
        #for i in range(0,N):
        #    UpdateLayerDuDr(layers, i)

        #4 - update the pressure for each layer
        #for i in range(0,N):
        #    UpdateLayerPressure(layers, i)

        #5 - calculate the radiative transfer in the layers
        print("STARTING RAD TRANS!!!!!!!!!!!!!!!!!!!!!!!!!")
        for i in range(0,N):
            UpdateLayerRadTrans(layers, i, F_uv, F_sol, F_long, kappa_uv, \
                    kappa_sol, kappa_long, uv_p_ref, sol_p_ref, long_p_ref, R_gas)

        #Update the temperature profile and calculate the diff
        #diff = UpdateTempProfile(layers, T_profile)

        ###########uncomment above line for running. TESTING ##################
        #get the pressure and distance profiles
        p_profile = np.zeros(N)
        r_profile = np.zeros(N)
        for i in range(0,N):
            p_profile[i] = (layers[i].p_bot+layers[i].p_top)/2.0 #just average it
            r_profile[i] = layers[i].r

        UpdateTempProfile(layers, T_profile)

        plt.plot(T_profile, p_profile)
        if count == 0:
            plt.gca().invert_yaxis()
        plt.xlabel("Temperature [K]")
        plt.ylabel("Pressure [Pa]")
        plt.title("Run %d of %d"%(count, iter_lim))
        plt.yscale('log')
        plt.pause(0.05)
        if count != iter_lim - 1:
            plt.cla()
        ######################################################################

        count += 1

    while True: #THIS IS FOR TESTING. DELTE IT
        plt.pause(0.05)

    if count == iter_lim:
        #we ended the while loop due to hitting the iter_lim
        print("failed to converge before iteration limit!")

    #get the pressure and distance profiles
    p_profile = np.zeros(N)
    r_profile = np.zeros(N)
    for i in range(0,N):
        p_profile[i] = (layers[i].p_bot+layers[i].p_top)/2.0 #just average it
        r_profile[i] = layers[i].r

    #calculate the mass flux loss rate
    u_top = layers[0].u
    r_top = layers[0].r
    rho_top = layers[0].rho
    mass_flux = 4.0*pi*rho_top*u_top*r_top**2.0 #loss rate [kg s-1]

    return (p_profile, r_profile, T_profile, mass_flux)




    



def test():
    results = BalanceAtmosphere(M_Earth, R_Earth, 5.148E18, 285.0, 0.0, 240.0, 0.0,\
        0.0, 0.0, 0.05, 1.0, 1.0, 1.0E4,\
        T_prof_in=[], N=100, iter_lim=500, tol=1.0E-4, p_toa_in=-1.0)

    p_profile, r_profile, T_profile, mass_flux = results

    print(T_profile)

    print("Finished with mass flux of: ", mass_flux)

    plt.plot(T_profile[::-1], p_profile)
    plt.xlabel("Temp [K]")
    plt.ylabel("Pressure [Pa]")
    plt.show()


test()

























    
